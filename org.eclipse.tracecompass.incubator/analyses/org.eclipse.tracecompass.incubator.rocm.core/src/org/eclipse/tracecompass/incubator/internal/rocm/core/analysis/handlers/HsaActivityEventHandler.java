/**********************************************************************
 * Copyright (c) 2022 École Polytechnique de Montréal
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License 2.0 which
 * accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/

package org.eclipse.tracecompass.incubator.internal.rocm.core.analysis.handlers;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.tracecompass.incubator.callstack.core.instrumented.statesystem.CallStackStateProvider;
import org.eclipse.tracecompass.incubator.callstack.core.instrumented.statesystem.InstrumentedCallStackAnalysis;
import org.eclipse.tracecompass.incubator.internal.rocm.core.analysis.RocmCallStackStateProvider;
import org.eclipse.tracecompass.incubator.internal.rocm.core.analysis.RocmStrings;
import org.eclipse.tracecompass.statesystem.core.ITmfStateSystemBuilder;
import org.eclipse.tracecompass.statesystem.core.exceptions.AttributeNotFoundException;
import org.eclipse.tracecompass.tmf.core.event.ITmfEvent;
import org.eclipse.tracecompass.tmf.core.statesystem.ITmfStateProvider.FutureEventType;

/**
 * The HSA activity event handler.<br>
 * It is possible to have different backends generate the GPU activity events.
 * This event handler is for the GPU activity events generated by HSA.
 *
 * @author Arnaud Fiorini
 */
public class HsaActivityEventHandler extends AbstractGpuEventHandler {

    /**
     * @param stateProvider
     *            The state provider that is using this event handler
     */
    public HsaActivityEventHandler(RocmCallStackStateProvider stateProvider) {
        super(stateProvider);
    }

    @Override
    public void handleEvent(ITmfStateSystemBuilder ssb, ITmfEvent event) throws AttributeNotFoundException {
        int copyQuark = ssb.getQuarkAbsoluteAndAdd(CallStackStateProvider.PROCESSES, RocmStrings.MEMORY);
        int tempQuark1 = ssb.getQuarkRelativeAndAdd(copyQuark, StringUtils.EMPTY);
        int tempQuark2 = ssb.getQuarkRelativeAndAdd(tempQuark1, RocmStrings.MEMORY_TRANSFERS);
        int callStackQuark = ssb.getQuarkRelativeAndAdd(tempQuark2, InstrumentedCallStackAnalysis.CALL_STACK);

        Long timestamp = event.getTimestamp().toNanos();
        Long timestampEnd = AbstractGpuEventHandler.getEndTime(event);
        ssb.pushAttribute(timestamp, RocmStrings.COPY, callStackQuark);
        if (timestampEnd != null) {
            fStateProvider.addFutureEvent(timestampEnd, null, callStackQuark, FutureEventType.POP);
        }
        // Add CallStack Identifier (tid equivalent) for the memory quark
        HostThreadIdentifier hostThreadIdentifier = new HostThreadIdentifier();
        addHostIdToStateSystemIfNotDefined(ssb, event.getTrace(), hostThreadIdentifier, callStackQuark);
    }
}
